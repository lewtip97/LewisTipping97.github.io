<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Lewis Tipping | Wainwright Explorer</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
			:root {
				--wainwright-card-padding: clamp(0.85rem, 1.8vw, 1.35rem);
			}

			.map-wrapper {
				display: grid;
				grid-template-columns: minmax(min(18vw, 200px), 240px) minmax(0, 1fr);
				grid-template-areas: "panel map";
				gap: clamp(1rem, 3vw, 2rem);
				align-items: start;
			}

			#wainwright-map {
				grid-area: map;
				height: clamp(420px, 65vh, 700px);
				border-radius: 0.75rem;
				overflow: hidden;
				box-shadow: 0 22px 45px -24px rgba(0, 0, 0, 0.65);
				min-width: 0;
			}

			.summit-panel {
				grid-area: panel;
				width: 100%;
				background: rgba(16, 23, 34, 0.92);
				border: 1px solid rgba(255, 255, 255, 0.08);
				border-radius: 0.8rem;
				padding: var(--wainwright-card-padding);
				backdrop-filter: blur(12px);
				display: flex;
				flex-direction: column;
				gap: 0.85rem;
				box-shadow: 0 18px 40px -24px rgba(0, 0, 0, 0.55);
			}

			.panel-header {
				display: grid;
				grid-template-columns: 1fr;
				gap: 0.4rem;
			}

			.panel-header h2 {
				font-size: 1.12rem;
				margin: 0;
			}

			.panel-summary {
				font-size: 0.66rem;
				color: rgba(255, 255, 255, 0.75);
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(92px, 1fr));
				gap: 0.25rem;
			}

			.panel-summary span {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 0.25rem;
				padding: 0.2rem 0.4rem;
				border-radius: 0.4rem;
				background: rgba(255, 255, 255, 0.05);
				border: 1px solid rgba(255, 255, 255, 0.08);
				white-space: nowrap;
			}

			.toggle-row {
				display: flex;
				flex-direction: column;
				gap: 0.4rem;
			}

			.toggle-option {
				display: inline-flex;
				align-items: center;
				gap: 0.3rem;
				font-size: 0.7rem;
				padding: 0.15rem 0.2rem;
				border-radius: 0.35rem;
				cursor: pointer;
				color: rgba(255, 255, 255, 0.82);
				transition: color 0.2s ease;
			}

			.toggle-option input[type="checkbox"] {
				accent-color: #4f9dde;
				width: 0.78rem;
				height: 0.78rem;
			}

			.toggle-option:hover,
			.toggle-option:focus-within {
				color: #fff;
			}

			.panel-instructions {
				margin: 0;
				font-size: 0.64rem;
				color: rgba(255, 255, 255, 0.6);
			}

			.mountain-icon {
				background: transparent;
				border: none;
				cursor: pointer;
				transition: transform 0.2s ease;
			}

			.mountain-icon:hover {
				transform: scale(1.2);
			}

			.mountain-icon svg {
				filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
			}

			.hover-card {
				position: absolute;
				background: rgba(16, 23, 34, 0.98);
				border: 1px solid rgba(255, 255, 255, 0.15);
				border-radius: 0.5rem;
				padding: 0.75rem 1rem;
				min-width: 180px;
				box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
				pointer-events: none;
				z-index: 1000;
				font-size: 0.75rem;
				backdrop-filter: blur(12px);
				opacity: 0;
				transform: translateY(-10px);
				transition: opacity 0.2s ease, transform 0.2s ease;
			}

			.hover-card.visible {
				opacity: 1;
				transform: translateY(0);
			}

			.hover-card__name {
				font-weight: 700;
				font-size: 0.85rem;
				color: rgba(255, 255, 255, 0.95);
				margin-bottom: 0.4rem;
			}

			.hover-card__meta {
				color: rgba(255, 255, 255, 0.7);
				font-size: 0.7rem;
				margin: 0.25rem 0;
			}

			.hover-card__status {
				display: inline-block;
				margin-top: 0.4rem;
				padding: 0.2rem 0.5rem;
				border-radius: 0.25rem;
				font-size: 0.65rem;
				font-weight: 600;
				text-transform: uppercase;
			}

			.hover-card__status.summited {
				background: rgba(48, 194, 109, 0.3);
				color: #30c26d;
			}

			.hover-card__status.unsummited {
				background: rgba(223, 91, 87, 0.3);
				color: #df5b57;
			}

			.wainwright-popup {
				color: #000;
				font-size: 0.9rem;
				line-height: 1.35;
			}

			.wainwright-popup strong {
				color: #000;
			}

			.wainwright-popup__meta,
			.wainwright-popup__status,
			.wainwright-popup__notes {
				color: #000;
				font-size: 0.85rem;
			}

			.wainwright-popup__notes {
				font-size: 0.8rem;
				opacity: 0.85;
			}

			.search-row {
				display: flex;
				flex-direction: column;
				gap: 0.35rem;
			}

			.search-row label {
				font-size: 0.64rem;
				font-weight: 600;
				color: rgba(255, 255, 255, 0.72);
				text-transform: uppercase;
				letter-spacing: 0.04em;
			}

			.search-row input {
				width: 100%;
				padding: 0.4rem 0.55rem;
				border-radius: 0.45rem;
				border: 1px solid rgba(255, 255, 255, 0.12);
				background: rgba(0, 0, 0, 0.25);
				color: rgba(255, 255, 255, 0.92);
				font-size: 0.7rem;
				transition: border-color 0.2s ease, background 0.2s ease;
			}

			.search-row input::placeholder {
				color: rgba(255, 255, 255, 0.45);
			}

			.search-row input:focus {
				outline: none;
				border-color: rgba(79, 157, 222, 0.6);
				background: rgba(12, 18, 26, 0.65);
			}

			.data-panels {
				margin-top: clamp(1.5rem, 3vw, 2.2rem);
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
				gap: 1.5rem;
			}

			.data-panel {
				background: rgba(10, 15, 23, 0.6);
				border: 1px solid rgba(255, 255, 255, 0.08);
				border-radius: 0.8rem;
				padding: clamp(1rem, 2.5vw, 1.5rem);
				display: flex;
				flex-direction: column;
				gap: 1rem;
			}

			.data-panel h2 {
				margin: 0;
				font-size: 1.12rem;
			}

			.hike-controls {
				display: flex;
				flex-wrap: wrap;
				align-items: flex-end;
				gap: 0.8rem;
				margin-top: 0.4rem;
			}

			.hike-controls label {
				display: block;
				font-size: 0.66rem;
				text-transform: uppercase;
				letter-spacing: 0.04em;
				color: rgba(255, 255, 255, 0.7);
				margin-bottom: 0.35rem;
			}

			.hike-controls input[type="number"] {
				width: 120px;
				padding: 0.45rem 0.6rem;
				border-radius: 0.45rem;
				border: 1px solid rgba(255, 255, 255, 0.12);
				background: rgba(0, 0, 0, 0.25);
				color: rgba(255, 255, 255, 0.92);
				font-size: 0.78rem;
			}

			.hike-controls button {
				white-space: nowrap;
			}

			.hike-results {
				display: flex;
				flex-direction: column;
				gap: 0.8rem;
			}

			.hike-card {
				border-radius: 0.6rem;
				border: 1px solid rgba(79, 157, 222, 0.3);
				background: rgba(12, 19, 29, 0.55);
				padding: 0.85rem 1rem;
				display: flex;
				flex-direction: column;
				gap: 0.45rem;
				transition: border-color 0.2s ease, background 0.2s ease;
				cursor: pointer;
			}

			.hike-card:hover {
				border-color: rgba(79, 157, 222, 0.6);
				background: rgba(12, 19, 29, 0.75);
			}

			.hike-card h3 {
				margin: 0;
				font-size: 1rem;
			}

			.hike-card p {
				margin: 0;
				font-size: 0.75rem;
				color: rgba(255, 255, 255, 0.75);
			}

			.hike-card ul {
				margin: 0;
				padding-left: 1.1rem;
				font-size: 0.72rem;
				color: rgba(255, 255, 255, 0.75);
			}

			.hike-card__meta {
				display: flex;
				gap: 0.6rem;
				flex-wrap: wrap;
				font-size: 0.72rem;
				color: rgba(255, 255, 255, 0.78);
			}

			.hike-card__badges {
				display: inline-flex;
				flex-wrap: wrap;
				gap: 0.4rem;
			}

			.hike-card__badge {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				padding: 0.12rem 0.45rem;
				border-radius: 999px;
				background: rgba(79, 157, 222, 0.12);
				border: 1px solid rgba(79, 157, 222, 0.35);
				font-size: 0.66rem;
				color: rgba(255, 255, 255, 0.85);
			}

			.hike-empty {
				font-size: 0.78rem;
				color: rgba(255, 255, 255, 0.6);
			}

			.fell-table-wrapper {
				border-radius: 0.5rem;
				border: 1px solid rgba(255, 255, 255, 0.06);
				background: rgba(6, 9, 13, 0.4);
				max-height: clamp(320px, 55vh, 520px);
				overflow-y: auto;
			}

			.fell-table-wrapper::-webkit-scrollbar {
				width: 0.4rem;
			}

			.fell-table-wrapper::-webkit-scrollbar-thumb {
				background: rgba(255, 255, 255, 0.15);
				border-radius: 2rem;
			}

			.fell-table {
				width: 100%;
				border-collapse: collapse;
				font-size: 0.66rem;
			}

			.fell-table thead {
				background: rgba(255, 255, 255, 0.04);
				text-transform: uppercase;
				letter-spacing: 0.08em;
			}

			.fell-table th {
				text-align: left;
				padding: 0.45rem 0.55rem;
				color: rgba(255, 255, 255, 0.65);
				font-weight: 600;
			}

			.fell-table td {
				padding: 0.4rem 0.55rem;
				border-top: 1px solid rgba(255, 255, 255, 0.05);
				vertical-align: middle;
			}

			.fell-row {
				transition: background 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
				border-left: 3px solid transparent;
			}

			.fell-row.is-summited {
				background: rgba(48, 194, 109, 0.28);
				border-left: 3px solid rgba(48, 194, 109, 0.65);
			}

			.fell-row.is-unsummited {
				background: rgba(223, 91, 87, 0.28);
				border-left: 3px solid rgba(223, 91, 87, 0.65);
			}

			.fell-row.is-active {
				box-shadow: inset 0 0 0 1px rgba(79, 157, 222, 0.65);
			}

			.fell-row.is-hidden {
				display: none;
			}

			.fell-name-cell .fell-focus {
				border: none;
				background: none;
				color: inherit;
				font: inherit;
				padding: 0;
				cursor: pointer;
				display: inline-flex;
				flex-direction: column;
				align-items: flex-start;
				gap: 0.12rem;
			}

			.fell-name-cell .fell-name {
				font-weight: 600;
				font-size: 0.78rem;
				color: rgba(255, 255, 255, 0.9);
			}

			.fell-name-cell .fell-meta {
				font-size: 0.6rem;
				color: rgba(255, 255, 255, 0.5);
			}

			.fell-table .fell-height-cell {
				color: rgba(255, 255, 255, 0.7);
			}

			.fell-table .fell-status-cell {
				white-space: nowrap;
				text-align: left;
			}

			.status-badge {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				padding: 0.25rem 0.5rem;
				border-radius: 0.3rem;
				font-size: 0.65rem;
				font-weight: 600;
				text-transform: uppercase;
				letter-spacing: 0.02em;
				color: #fff;
				background: rgba(223, 91, 87, 0.8);
				cursor: pointer;
				transition: background 0.2s ease, transform 0.1s ease;
				user-select: none;
			}

			.status-badge:hover {
				transform: scale(1.05);
			}

			.status-badge:active {
				transform: scale(0.98);
			}

			.status-badge.is-summited {
				background: rgba(48, 194, 109, 0.85);
			}


			@media (max-width: 1080px) {
				.map-wrapper {
					grid-template-columns: minmax(0, 1fr);
					grid-template-areas:
						"map"
						"panel";
				}

				.summit-panel {
					margin-top: 1.25rem;
				}

				.panel-summary {
					white-space: normal;
				}

				#wainwright-map {
					height: clamp(360px, 60vh, 600px);
				}
			}

			@media (max-width: 640px) {
				#wainwright-map {
					height: clamp(360px, 60vh, 520px);
				}

				.fell-controls {
					width: 100%;
					flex-direction: row;
					align-items: center;
					justify-content: space-between;
				}
			}
		</style>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Lewis Tipping</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="generic.html">Professional experience</a></li>
						<li><a href="wainwrights.html" class="active">Wainwright Explorer</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper style1 fade-up">
						<div class="inner">
							<h1 class="major">Plotting the Wainwrights</h1>
							<p>Explore all 214 Wainwright fells across England&rsquo;s Lake District. Track completed summits, focus the map on any fell, and spot what&rsquo;s left to conquer.</p>

							<div class="map-wrapper">
								<div id="wainwright-map" role="region" aria-label="Interactive map of the Lake District showing Wainwright fells"></div>

								<aside class="summit-panel" id="summit-panel">
									<div class="panel-header">
										<h2>Summit tracker</h2>
										<div class="panel-summary" id="fell-summary">Loading peaks…</div>
									</div>

									<div class="toggle-row">
										<label class="toggle-option">
											<input type="checkbox" id="toggle-unsummited" checked />
											<span>Show unsummited</span>
										</label>
										<label class="toggle-option">
											<input type="checkbox" id="toggle-summited" checked />
											<span>Show summited</span>
										</label>
									</div>

									<p class="panel-instructions">Mark the fells you&rsquo;ve completed and click any name to fly to its location.</p>

									<div class="hike-controls">
										<div>
											<label for="max-distance">Max distance per hike (km)</label>
											<input type="number" id="max-distance" min="1" step="1" value="15" />
										</div>
										<button id="generate-hikes" class="button primary small">Generate hikes</button>
										<div id="api-notice" style="display: none; margin-top: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.6);">
											Note: Hike generation requires a backend service. The map and peak tracking work without it.
										</div>
									</div>
								</aside>
							</div>

							<div class="data-panels">
								<div class="data-panel peaks-panel">
									<h2>Peaks overview</h2>
									<div class="search-row">
										<label for="fell-search">Search fells</label>
										<input type="search" id="fell-search" placeholder="Search by name or grid reference…" />
									</div>

									<div class="fell-table-wrapper">
										<table class="fell-table">
											<thead>
												<tr>
													<th scope="col" class="fell-status-cell">Status</th>
													<th scope="col">Fell</th>
													<th scope="col">Height / Ref</th>
												</tr>
											</thead>
											<tbody id="fell-table-body"></tbody>
										</table>
									</div>
								</div>

								<div class="data-panel hikes-panel">
									<h2>Generated hikes</h2>
									<p class="panel-instructions" style="margin:0;">Routes will appear here once generated. Hover to highlight, click to zoom the map.</p>
									<div id="hike-results" class="hike-results"></div>
								</div>
							</div>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper style1-alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.js" crossorigin="anonymous"></script>
			<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
			<script>
				// API base URL configuration
				// - Empty string: No backend (GitHub Pages only)
				// - 'http://localhost:8005': Local development
				// - 'https://your-service.onrender.com': Render deployment
				// Update this with your Render service URL after deployment
				window.WAINWRIGHT_API_BASE = '';
			</script>
			<script>
				window.addEventListener('DOMContentLoaded', () => {
					const mapContainer = document.getElementById('wainwright-map');
					const tableBody = document.getElementById('fell-table-body');
					const summaryEl = document.getElementById('fell-summary');
					const toggleUnsummited = document.getElementById('toggle-unsummited');
					const toggleSummited = document.getElementById('toggle-summited');
					const searchInput = document.getElementById('fell-search');
					const maxDistanceInput = document.getElementById('max-distance');
					const generateButton = document.getElementById('generate-hikes');
					const hikeResultsEl = document.getElementById('hike-results');

					const API_BASE_URL = window.WAINWRIGHT_API_BASE || '';
					const API_AVAILABLE = API_BASE_URL !== '';
					const HIKE_COLORS = ['#4F9DDE', '#F29E4C', '#2ECC71', '#E96479', '#9C6ADE', '#FFB347', '#00A676'];
					let fellCatalog = [];
					let hikeLayers = [];

					if (!mapContainer || !tableBody) {
						return;
					}

					if (typeof proj4 === 'undefined' || typeof L === 'undefined') {
						console.error('Mapping libraries are unavailable.');
						if (summaryEl) summaryEl.textContent = 'Map libraries unavailable';
						mapContainer.innerHTML = '<p>Sorry, the Wainwright map could not be loaded.</p>';
						return;
					}

					const STORAGE_KEY = 'wainwrightSummits';
					const loadSummited = () => {
						try {
							const raw = localStorage.getItem(STORAGE_KEY);
							const parsed = raw ? JSON.parse(raw) : [];
							return Array.isArray(parsed) ? parsed : [];
						} catch (error) {
							console.warn('Unable to load summit history', error);
							return [];
						}
					};
					const summitedSet = new Set(loadSummited());
					const persistSummited = () => {
						try {
							localStorage.setItem(STORAGE_KEY, JSON.stringify([...summitedSet]));
						} catch (error) {
							console.warn('Unable to persist summit history', error);
						}
					};

					const state = {
						showSummited: toggleSummited ? toggleSummited.checked : true,
						showUnsummited: toggleUnsummited ? toggleUnsummited.checked : true,
						searchQuery: searchInput ? searchInput.value.trim().toLowerCase() : ''
					};

					const createMountainIcon = (isSummited) => {
						const color = isSummited ? '#30c26d' : '#df5b57';
						const iconHtml = `
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M12 3L2 21h20L12 3z" fill="${color}" stroke="${color}" stroke-width="1.5" stroke-linejoin="round"/>
								<path d="M12 8L8 15h8L12 8z" fill="rgba(255,255,255,0.3)"/>
							</svg>
						`;
						return L.divIcon({
							html: iconHtml,
							className: 'mountain-icon',
							iconSize: [24, 24],
							iconAnchor: [12, 24],
							popupAnchor: [0, -24]
						});
					};

					const hoverCard = document.createElement('div');
					hoverCard.className = 'hover-card';
					document.body.appendChild(hoverCard);
					let currentHoverMarker = null;
					let currentHoverFell = null;
					let currentHoverIsSummited = false;

					const updateHoverCardPosition = (marker, map) => {
						if (!hoverCard.classList.contains('visible') || !marker) return;
						const iconPos = map.latLngToContainerPoint(marker.getLatLng());
						const mapContainer = map.getContainer();
						const mapRect = mapContainer.getBoundingClientRect();
						
						hoverCard.style.left = (mapRect.left + iconPos.x - hoverCard.offsetWidth / 2) + 'px';
						hoverCard.style.top = (mapRect.top + iconPos.y - hoverCard.offsetHeight - 15) + 'px';
					};

					const showHoverCard = (fell, isSummited, marker, map) => {
						currentHoverMarker = marker;
						currentHoverFell = fell;
						currentHoverIsSummited = isSummited;
						const parts = [
							fell.height ? `${fell.height} m` : null,
							fell.prominence ? `p${fell.prominence}` : null
						].filter(Boolean);
						
						hoverCard.innerHTML = `
							<div class="hover-card__name">${fell.displayName}</div>
							${parts.length ? `<div class="hover-card__meta">${parts.join(' · ')}</div>` : ''}
							<div class="hover-card__meta">Grid: ${fell.gridRef}</div>
							<div class="hover-card__status ${isSummited ? 'summited' : 'unsummited'}">${isSummited ? 'Summited' : 'Unsummited'}</div>
						`;
						
						updateHoverCardPosition(marker, map);
						hoverCard.classList.add('visible');
					};

					const hideHoverCard = () => {
						currentHoverMarker = null;
						currentHoverFell = null;
						hoverCard.classList.remove('visible');
					};

					const OSGB_PROJ = 'EPSG:27700';
					const WGS84_PROJ = 'EPSG:4326';

					proj4.defs(OSGB_PROJ, '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +srid=27700 +towgs84=446.448,-125.157,542.06,0.1502,0.2470,0.8421,-20.4894 +units=m +no_defs');

					const gridRefToEN = (gridRef) => {
						if (!gridRef) return null;
						const normalized = gridRef.toUpperCase().replace(/\s+/g, '');
						if (normalized.length < 2) return null;

						const charCodeA = 'A'.charCodeAt(0);
						let l1 = normalized.charCodeAt(0) - charCodeA;
						let l2 = normalized.charCodeAt(1) - charCodeA;
						if (l1 < 0 || l2 < 0) return null;

						if (l1 > 7) l1 -= 1;
						if (l2 > 7) l2 -= 1;

						const e100km = ((((l1 - 2 + 25) % 5) * 5) + (l2 % 5)) * 100000;
						const n100km = ((19 - Math.floor(l1 / 5) * 5) - Math.floor(l2 / 5)) * 100000;

						if (e100km < 0 || n100km < 0) return null;

						const remainder = normalized.slice(2);
						const precision = remainder.length / 2;
						if (!precision || remainder.length % 2 !== 0) return null;

						const scale = Math.pow(10, 5 - precision);
						const eastingDigits = parseInt(remainder.slice(0, precision), 10);
						const northingDigits = parseInt(remainder.slice(precision), 10);
						if (!Number.isFinite(eastingDigits) || !Number.isFinite(northingDigits)) {
							return null;
						}

						const easting = e100km + eastingDigits * scale;
						const northing = n100km + northingDigits * scale;

						return Number.isFinite(easting) && Number.isFinite(northing)
							? { easting, northing }
							: null;
					};

					const gridRefToLatLng = (gridRef) => {
						const en = gridRefToEN(gridRef);
						if (!en) return null;
						const projected = proj4(OSGB_PROJ, WGS84_PROJ, [en.easting, en.northing]);
						return projected ? { lng: projected[0], lat: projected[1] } : null;
					};

					const parseCsvLine = (line) => {
						const trimmed = line.trim();
						if (!trimmed) return null;
						const unquoted = trimmed.replace(/^"|"$/g, '');
						const tokens = unquoted.split(/\s+/);
						if (tokens.length < 3) return null;

						const rawCode = tokens[0];
						const gridRef = tokens[1];
						const nameWithMeta = unquoted.slice(unquoted.indexOf(gridRef) + gridRef.length).trim();
						const displayName = nameWithMeta.replace(/\s*\(([^)]+)\)\s*$/, '').trim();
						const heightMatch = nameWithMeta.match(/(\d+)\s*m/i);
						const height = heightMatch ? parseInt(heightMatch[1], 10) : null;
						const prominenceMatch = nameWithMeta.match(/p(\d+(\.\d+)?)/i);
						const prominence = prominenceMatch ? parseFloat(prominenceMatch[1]) : null;
						const notes = nameWithMeta.includes('(')
							? nameWithMeta.slice(nameWithMeta.indexOf('(') + 1, nameWithMeta.lastIndexOf(')')).trim()
							: null;
						const code = rawCode.replace(/[^0-9A-Za-z]/g, '');
						const sanitizedGridRef = gridRef.replace(/\s+/g, '').toUpperCase();

						return {
							id: `${code || 'FELL'}_${sanitizedGridRef || displayName.replace(/\s+/g, '_')}`,
							gridRef,
							displayName,
							fullLabel: nameWithMeta,
							height,
							prominence,
							notes
						};
					};

					const buildPopupContent = (fell, isSummited) => {
						const parts = [
							fell.height ? `${fell.height} m summit` : 'Height unknown',
							fell.prominence ? `prominence ${fell.prominence} m` : null
						].filter(Boolean);
						const statusLabel = isSummited ? 'Summited' : 'Unsummited';

						return `
							<div class="wainwright-popup">
								<strong>${fell.displayName}</strong>
								${parts.length ? `<div class="wainwright-popup__meta">${parts.join(' · ')}</div>` : ''}
								<div class="wainwright-popup__meta">Grid Ref: ${fell.gridRef}</div>
								<div class="wainwright-popup__status">Status: ${statusLabel}</div>
								${fell.notes ? `<div class="wainwright-popup__notes">${fell.notes}</div>` : ''}
							</div>
						`;
					};

					const map = L.map(mapContainer, {
						center: [54.5, -3.2],
						zoom: 9,
						scrollWheelZoom: true
					});

					L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
						maxZoom: 19,
						attribution: '&copy; Esri &mdash; Source: Esri, Maxar, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'
					}).addTo(map);

					// Update hover card position on map move/zoom
					map.on('move', () => {
						if (currentHoverMarker) {
							updateHoverCardPosition(currentHoverMarker, map);
						}
					});
					map.on('zoom', () => {
						if (currentHoverMarker) {
							updateHoverCardPosition(currentHoverMarker, map);
						}
					});

					const layerGroup = L.layerGroup().addTo(map);

					const updateSummary = (visible, totalFells) => {
						if (!summaryEl) return;
						const totalSummited = summitedSet.size;
						const totalRemaining = totalFells - totalSummited;
						summaryEl.innerHTML = `
							<span><strong>${visible}</strong> showing</span>
							<span><strong>${totalSummited}</strong> completed</span>
							<span><strong>${totalRemaining}</strong> remaining</span>
						`;
					};

					const clearHikeLayers = () => {
						hikeLayers.forEach(({ layer }) => {
							if (layer && map.hasLayer(layer)) {
								map.removeLayer(layer);
							}
						});
						hikeLayers = [];
					};

					const renderHikeResults = (hikes) => {
						if (!hikeResultsEl) return;
						hikeResultsEl.innerHTML = '';

						if (!hikes.length) {
							const message = document.createElement('p');
							message.className = 'hike-empty';
							message.textContent = 'No hikes generated. Adjust the distance or summit selections.';
							hikeResultsEl.appendChild(message);
							return;
						}

						hikes.forEach((hike, index) => {
							const card = document.createElement('div');
							card.className = 'hike-card';
								const color = hikeLayers[index]?.color || '#4F9DDE';
								card.style.borderColor = color;
							if (color.startsWith('#') && color.length === 7) {
								card.style.background = `${color}1a`;
								card.style.boxShadow = `0 16px 32px -20px ${color}cc`;
							}
							card.innerHTML = `
								<h3>Hike ${index + 1}</h3>
								<div class="hike-card__meta">
									<span>${hike.distance_km} km</span>
									<div class="hike-card__badges">
										<span class="hike-card__badge">${hike.fell_ids.length} peak${hike.fell_ids.length === 1 ? '' : 's'}</span>
									</div>
								</div>
								<p>Peaks covered:</p>
								<ul>${hike.fell_names.map((name) => `<li>${name}</li>`).join('')}</ul>
							`;
							card.addEventListener('mouseenter', () => {
								const entry = hikeLayers[index];
								if (entry?.layer) entry.layer.setStyle({ weight: 6, color });
							});
							card.addEventListener('mouseleave', () => {
								const entry = hikeLayers[index];
								if (entry?.layer) entry.layer.setStyle({ weight: 4, color });
							});
							card.addEventListener('click', () => {
								const entry = hikeLayers[index];
								if (entry?.layer) {
									map.fitBounds(entry.layer.getBounds().pad(0.2));
								}
							});
							hikeResultsEl.appendChild(card);
						});
					};

					const drawHikePolylines = (hikes) => {
						clearHikeLayers();
						const bounds = L.latLngBounds();

						hikes.forEach((hike, index) => {
							const color = HIKE_COLORS[index % HIKE_COLORS.length];
							const latlngs = hike.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
							const layer = L.polyline(latlngs, {
								color,
								weight: 4,
								opacity: 0.95,
								dashArray: '8, 6'
							}).addTo(map);
							hikeLayers.push({ layer, color });
							layer.bindPopup(`<strong>Hike ${index + 1}</strong><br>${hike.distance_km} km · ${hike.fell_ids.length} peaks`);
							bounds.extend(layer.getBounds());
						});

						if (bounds.isValid()) {
							map.fitBounds(bounds.pad(0.2));
						}
					};

					const fetchAndRender = async () => {
						try {
							const response = await fetch('ListOfWainrights.csv');
							if (!response.ok) throw new Error('Unable to load Wainwright dataset.');
							const text = await response.text();
							const lines = text.split(/\r?\n/).slice(1).filter(Boolean);
							const parsedFells = lines
								.map(parseCsvLine)
								.filter(Boolean)
								.map((fell) => {
									const coords = gridRefToLatLng(fell.gridRef);
									if (!coords) return null;
									return {
										...fell,
										lat: coords.lat,
										lng: coords.lng
									};
								})
								.filter(Boolean);

							if (!parsedFells.length) {
								throw new Error('No Wainwright peaks could be parsed.');
							}
							fellCatalog = parsedFells;

							const totalFells = parsedFells.length;
							const markersById = new Map();
							const listItemsById = new Map();
							let activeRowId = null;

							const matchesSearch = (fell) => {
								if (!state.searchQuery) return true;
								const query = state.searchQuery;
								return (
									fell.displayName.toLowerCase().includes(query) ||
									fell.gridRef.toLowerCase().includes(query) ||
									(fell.fullLabel && fell.fullLabel.toLowerCase().includes(query))
								);
							};

							const shouldShowFell = (fell) => {
								const isSummited = summitedSet.has(fell.id);
								if (!matchesSearch(fell)) return false;
								return (isSummited && state.showSummited) || (!isSummited && state.showUnsummited);
							};

							const focusRow = (id, { scroll = true } = {}) => {
								if (activeRowId && listItemsById.has(activeRowId)) {
									listItemsById.get(activeRowId).row.classList.remove('is-active');
								}

								const entry = listItemsById.get(id);
								if (entry) {
									entry.row.classList.add('is-active');
									if (scroll) {
										entry.row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
									}
									activeRowId = id;
								}
							};

							const updateRowState = (fell) => {
								const entry = listItemsById.get(fell.id);
								if (!entry) return;
								const isSummited = summitedSet.has(fell.id);
								entry.row.classList.toggle('is-summited', isSummited);
								entry.row.classList.toggle('is-unsummited', !isSummited);
								entry.badge.textContent = isSummited ? 'Summited' : 'Unsummited';
								entry.badge.classList.toggle('is-summited', isSummited);
								entry.badge.classList.toggle('is-unsummited', !isSummited);
							};

							const updateMarkerAppearance = (fell) => {
								const marker = markersById.get(fell.id);
								if (!marker) return;
								const isSummited = summitedSet.has(fell.id);
								marker.setIcon(createMountainIcon(isSummited));
								marker.setPopupContent(buildPopupContent(fell, isSummited));
							};

							const refreshVisibility = () => {
								let visible = 0;

								parsedFells.forEach((fell) => {
									const marker = markersById.get(fell.id);
									const entry = listItemsById.get(fell.id);
									const show = shouldShowFell(fell);

									if (marker) {
										if (show) {
											if (!layerGroup.hasLayer(marker)) {
												marker.addTo(layerGroup);
											}
											visible += 1;
										} else if (layerGroup.hasLayer(marker)) {
											layerGroup.removeLayer(marker);
										}
									}

									if (entry) {
										entry.row.classList.toggle('is-hidden', !show);
										entry.row.classList.toggle('is-summited', summitedSet.has(fell.id));
										entry.row.classList.toggle('is-unsummited', !summitedSet.has(fell.id));
										if (!show && activeRowId === fell.id) {
											entry.row.classList.remove('is-active');
											activeRowId = null;
										}
									}
								});

								updateSummary(visible, totalFells);

								if (visible > 0 && (!activeRowId || (activeRowId && listItemsById.has(activeRowId) && listItemsById.get(activeRowId).row.classList.contains('is-hidden')))) {
									const firstVisible = parsedFells.find((fell) => {
										const entry = listItemsById.get(fell.id);
										return entry && !entry.row.classList.contains('is-hidden');
									});
									if (firstVisible) {
										focusRow(firstVisible.id, { scroll: false });
									}
								}
							};

							const ensureFellVisible = (fell) => {
								const isSummited = summitedSet.has(fell.id);
								const matches = matchesSearch(fell);

								if (!matches && searchInput) {
									state.searchQuery = '';
									searchInput.value = '';
								}

								if (isSummited && !state.showSummited && toggleSummited) {
									state.showSummited = true;
									toggleSummited.checked = true;
								}
								if (!isSummited && !state.showUnsummited && toggleUnsummited) {
									state.showUnsummited = true;
									toggleUnsummited.checked = true;
								}

								refreshVisibility();
							};

							tableBody.innerHTML = '';
							const sortedFells = [...parsedFells].sort((a, b) => {
								if (typeof a.height === 'number' && typeof b.height === 'number') {
									return b.height - a.height;
								}
								if (typeof a.height === 'number') return -1;
								if (typeof b.height === 'number') return 1;
								return a.displayName.localeCompare(b.displayName);
							});

							sortedFells.forEach((fell) => {
								const row = document.createElement('tr');
								row.className = 'fell-row';
								row.dataset.fellId = fell.id;

								const nameCell = document.createElement('td');
								nameCell.className = 'fell-name-cell';

								const focusButton = document.createElement('button');
								focusButton.type = 'button';
								focusButton.className = 'fell-focus';

								const metaParts = [];
								if (typeof fell.height === 'number') {
									metaParts.push(`${fell.height} m`);
								}
								if (typeof fell.prominence === 'number') {
									metaParts.push(`p${fell.prominence}`);
								}
								const meta = metaParts.join(' · ');

								focusButton.innerHTML = `
									<span class="fell-name">${fell.displayName}</span>
									<span class="fell-meta">${meta || fell.gridRef}</span>
								`;
								nameCell.appendChild(focusButton);

								const heightCell = document.createElement('td');
								heightCell.className = 'fell-height-cell';
								heightCell.textContent = meta ? `${meta} · ${fell.gridRef}` : fell.gridRef;

								const statusCell = document.createElement('td');
								statusCell.className = 'fell-status-cell';

								const badge = document.createElement('span');
								badge.className = 'status-badge';
								badge.textContent = summitedSet.has(fell.id) ? 'Summited' : 'Unsummited';
								if (summitedSet.has(fell.id)) {
									badge.classList.add('is-summited');
								} else {
									badge.classList.add('is-unsummited');
								}

								statusCell.appendChild(badge);

								row.append(statusCell, nameCell, heightCell);
								tableBody.appendChild(row);

								listItemsById.set(fell.id, {
									row,
									badge,
									focusButton
								});

								focusButton.addEventListener('click', () => {
									ensureFellVisible(fell);
									focusRow(fell.id);
									const marker = markersById.get(fell.id);
									if (marker) {
										map.flyTo([fell.lat, fell.lng], Math.max(map.getZoom(), 11), { duration: 0.8 });
										marker.openPopup();
									}
								});

								badge.addEventListener('click', () => {
									const isSummited = summitedSet.has(fell.id);
									if (isSummited) {
										summitedSet.delete(fell.id);
									} else {
										summitedSet.add(fell.id);
									}
									persistSummited();
									updateRowState(fell);
									updateMarkerAppearance(fell);
									refreshVisibility();
								});
							});

							parsedFells.forEach((fell) => {
								updateRowState(fell);
								const isSummited = summitedSet.has(fell.id);
								const marker = L.marker(
									[fell.lat, fell.lng],
									{ icon: createMountainIcon(isSummited) }
								);
								marker.bindPopup(buildPopupContent(fell, isSummited));
								marker.on('popupopen', () => focusRow(fell.id));
								
								// Add hover events
								marker.on('mouseover', () => {
									showHoverCard(fell, isSummited, marker, map);
								});
								
								marker.on('mouseout', () => {
									hideHoverCard();
								});
								
								markersById.set(fell.id, marker);
							});

							if (toggleUnsummited) {
								toggleUnsummited.addEventListener('change', () => {
									state.showUnsummited = toggleUnsummited.checked;
									refreshVisibility();
								});
							}

							if (toggleSummited) {
								toggleSummited.addEventListener('change', () => {
									state.showSummited = toggleSummited.checked;
									refreshVisibility();
								});
							}

							if (searchInput) {
								searchInput.addEventListener('input', () => {
									state.searchQuery = searchInput.value.trim().toLowerCase();
									refreshVisibility();
								});
							}

							refreshVisibility();

							if (sortedFells.length) {
								focusRow(sortedFells[0].id, { scroll: false });
							}

							if (generateButton) {
								const apiNotice = document.getElementById('api-notice');
								if (!API_AVAILABLE) {
									generateButton.disabled = true;
									generateButton.textContent = 'Backend service required';
									if (apiNotice) apiNotice.style.display = 'block';
								} else {
									generateButton.addEventListener('click', async () => {
										const maxDistance = parseFloat(maxDistanceInput?.value || '0');
										if (!Number.isFinite(maxDistance) || maxDistance <= 0) {
											alert('Please enter a valid maximum distance (km).');
											return;
										}

										const body = {
											max_distance_km: maxDistance,
											fells: fellCatalog.map((fell) => ({
												id: fell.id,
												name: fell.displayName,
												lat: fell.lat,
												lon: fell.lng,
												summited: summitedSet.has(fell.id)
											}))
										};

										try {
											generateButton.disabled = true;
											generateButton.textContent = 'Generating…';

											const response = await fetch(`${API_BASE_URL}/api/hikes`, {
												method: 'POST',
												headers: { 'Content-Type': 'application/json' },
												body: JSON.stringify(body)
											});

											if (!response.ok) {
												throw new Error('Failed to generate hikes');
											}

											const data = await response.json();
											const hikes = data.hikes || [];
											drawHikePolylines(hikes);
											renderHikeResults(hikes);
										} catch (error) {
											console.error(error);
											alert('Unable to generate hikes. Please check the backend service.');
										} finally {
											generateButton.disabled = false;
											generateButton.textContent = 'Generate hikes';
										}
									});
								}
							}
						} catch (error) {
							console.error(error);
							if (summaryEl) summaryEl.textContent = 'Unable to load peaks';
							mapContainer.innerHTML = '<p>Sorry, the Wainwright map could not be loaded.</p>';
						}
					};

					fetchAndRender();
				});
			</script>

	</body>
</html>

